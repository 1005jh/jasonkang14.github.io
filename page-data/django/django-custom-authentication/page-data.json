{"componentChunkName":"component---src-templates-post-template-js","path":"/django/django-custom-authentication","webpackCompilationHash":"f77f954adcf779fa233d","result":{"data":{"markdownRemark":{"id":"4743cd1b-b8c7-5255-92f5-78e4386d6f38","html":"<h3 id=\"djangos-official-documentation-about-customizing-authentication-can-be-found-here\"><a href=\"#djangos-official-documentation-about-customizing-authentication-can-be-found-here\" aria-label=\"djangos official documentation about customizing authentication can be found here permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Djangoâ€™s official documentation about customizing authentication can be found <a href=\"https://docs.djangoproject.com/en/3.0/topics/auth/customizing/#customizing-authentication-in-django\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a></h3>\n<p>In order to create custom authentication, you have to create a model. You can extend the existing <strong>User</strong> model from <code class=\"language-text\">django.contrib.auth.models</code> and create an one-to-one relationship with your model and the default <strong>User</strong> model. However, I cannot assure this because I ahve not done it myself, but I believe this would create an extra table in your database. So I have decided to substitute a custom <strong>User</strong> model by using <strong>AbstractUser</strong> from <code class=\"language-text\">django.contrib.auth.models</code> like below;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class User(AbstractUser):\n    nickname      = models.CharField(max_length=15, unique=True)\n    phone         = models.CharField(max_length=15, default=&quot;010-1234-1234&quot;, unique=True)\n    date_of_birth = models.DateField()</code></pre></div>\n<p><code class=\"language-text\">birthday</code> could be a better name for the field, but I just decided to go with <code class=\"language-text\">date_of_birth</code>. Unless you create a completely new model for your <code class=\"language-text\">User</code>, the default <strong>User</strong> object has some primary attributes like <strong>username</strong>, <strong>password</strong>, <strong>email</strong>, <strong>first_name</strong>, and <strong>last_name</strong>. The model also has some other attributes like <strong>is_superuser</strong>, <strong>is_staff</strong>, and so on.</p>\n<p>Now you have to authenticate this user via a sign up request. I decided to go with a class view because I wanted to use a <code class=\"language-text\">get</code> request for sign up to check if a user with the same username, nickname, and/or email already exists.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import json\n\nfrom django.http         import JsonResponse, HttpResponse\nfrom django.views        import View\nfrom django.contrib.auth import authenticate, login\n\nfrom .models             import *                                 ## I take Align very seriously\n\nclass SignupView(View):\n    def post(self, request):\n        new_user_info = json.loads(request.body)\n        req_username  = new_user_info[&#39;username&#39;]\n        req_phone     = new_user_info[&#39;phone&#39;]\n        req_email     = new_user_info[&#39;email&#39;]\n\n        if User.objects.filter(username=req_username).exists():\n            return JsonResponse({\n                &#39;message&#39;: &#39;USERNAME_ALREADY_EXISTS&#39;\n            }, status=409)\n\n        elif User.objects.filter(phone=req_phone).exists():\n            return JsonResponse({\n                &#39;message&#39;: &#39;PHONE_NUMBER_ALREADY_EXISTS&#39;\n            }, status=409)\n\n        elif User.objects.filter(email=req_email).exists():\n            return JsonResponse({\n                &#39;message&#39;: &#39;EMAIL_ALREADY_EXISTS&#39;\n            }, status=409)\n\n        else:\n            new_user = User.objects.create_user(\n                username      = req_username,\n                phone         = req_phone,\n                email         = req_email,\n                first_name    = new_user_info[&#39;first_name&#39;],\n                last_name     = new_user_info[&#39;last_name&#39;],\n                password      = new_user_info[&#39;password&#39;],\n                nickname      = new_user_info[&#39;nickname&#39;],\n                date_of_birth = new_user_info[&#39;dateOfBirth&#39;],\n                height        = new_user_info[&#39;height&#39;],\n                body_type     = new_user_info[&#39;bodyType&#39;],\n                occupation    = new_user_info[&#39;occupation&#39;],\n            )\n\n            new_user = authenticate(username=req_username, password=new_user_info[&#39;password&#39;])\n\n            return HttpResponse(status=200)</code></pre></div>\n<p>I used 409 status if a user with same info already exists because <code class=\"language-text\">409 Conflict</code> is used in situations <strong>where it is iexpected that the user might be able to resolve the conflict and resubmit the request</strong>. Since the user can enter a new username, nickname, and/or email to resolve the <strong>conflict</strong> I used 409 as the status code.</p>\n<p>After creating a user by using <code class=\"language-text\">User.objects.create_user</code>, you have to <strong>authenticate</strong> the user via <code class=\"language-text\">new_user = authenticate(username=req_username, password=new_user_info[&#39;password&#39;])</code> in order to set the password. I will write about login in a later post</p>","fields":{"slug":"/django/django-custom-authentication","tagSlugs":["/tag/django/"]},"frontmatter":{"date":"2020-05-12T21:53:37.121Z","description":"How to create a custom user model and authentication method in Django","tags":["django"],"title":"Django - Custom Authentication"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/django/django-custom-authentication"}}}