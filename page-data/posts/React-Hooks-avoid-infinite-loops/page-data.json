{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/React-Hooks-avoid-infinite-loops","webpackCompilationHash":"804018378efbcedd28f4","result":{"data":{"markdownRemark":{"id":"e6fd4964-d670-5232-acb9-ffe23827688b","html":"<p>React came out with a new feature called <code class=\"language-text\">React Hooks</code>. As I work on a group project with three other people at a coding bootcamp, I decided to use this new feature.</p>\n<p>Before <code class=\"language-text\">React Hooks</code>, you had to use a <code class=\"language-text\">class</code> in order for your React component to have a state. But with <code class=\"language-text\">React Hooks</code>, your function component can have a state like below.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Party = () =&gt; {\n    const [joinBtnClicked, setJoinBtnClicked] = useState(true);</code></pre></div>\n<p>This is very straight-forward.</p>\n<ol>\n<li>I made a state called <code class=\"language-text\">joinBtnClicked</code>.</li>\n<li><code class=\"language-text\">useState()</code> method allows me to declare the initial <code class=\"language-text\">state</code> of <code class=\"language-text\">joinBtnClicked</code>.</li>\n<li>I can change the state of <code class=\"language-text\">joinBtnClicked</code> with a method called <code class=\"language-text\">setJoinBtnClicked</code> like below.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const displayPartyGenerationField = () =&gt; {\n    setJoinBtnClicked(false);\n}</code></pre></div>\n<p><code class=\"language-text\">React Hooks</code> makes my code a lot more efficient and easier to understand.</p>\n<p>I don’t need to use lifecycle methods such as <code class=\"language-text\">componenetDidMount()</code> or <code class=\"language-text\">componentWillUnmount()</code> anymore. I just use one method called <code class=\"language-text\">useEffect()</code> which deals with all the lifecycle methods. But I actually ran into a problem while using this method.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">useEffect(() =&gt; {\n    fetch (`${ADDRESS}party`, {mode: &#39;cors&#39;})\n        .then (\n            (response) =&gt; {\n                response.json().then((data) =&gt; {\n                    const length = data.length;\n                    for(let i=0; i &lt; length; i++) {\n                        for (let key in data[i]) {\n                            oldParty[key] = data[i][key];\n                        }\n                        oldParty.time = oldParty.time.slice(0, -3);\n                        oldPartyArr.push(oldParty);\n                        oldParty = {};\n                    }\n                    displayParties();\n                    setPartyArr(oldPartyArr);\n                })\n            }\n        )\n})</code></pre></div>\n<p>With the above code, I am retrieving a list of parties that had been formed by other users, so that I can pick a party to join myself. However, when I executed this code, <code class=\"language-text\">useEffect()</code> kept re-rendering while I needed it to render only once.</p>\n<p>According to <code class=\"language-text\">React.js</code>,\n<code class=\"language-text\">If you want to run an effect and clean it up only once (on mount and unmount), you can pass an empty array ([]) as a second argument. This tells React that your effect doesn’t depend on any values from props or state, so it never needs to re-run.</code></p>\n<p>So, I simply added [] as an argument like below and the problem was solved.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">useEffect(() =&gt; {\n    fetch (`${ADDRESS}party`, {mode: &#39;cors&#39;})\n        .then (\n            (response) =&gt; {\n                response.json().then((data) =&gt; {\n                    const length = data.length;\n                    for(let i=0; i &lt; length; i++) {\n                        for (let key in data[i]) {\n                            oldParty[key] = data[i][key];\n                        }\n                        oldParty.time = oldParty.time.slice(0, -3);\n                        oldPartyArr.push(oldParty);\n                        oldParty = {};\n                    }\n                    displayParties();\n                    setPartyArr(oldPartyArr);\n                })\n            }\n        )\n},[])</code></pre></div>","fields":{"slug":"/posts/React-Hooks-avoid-infinite-loops","tagSlugs":["/tag/react/","/tag/reacthooks/"]},"frontmatter":{"date":"2019-07-01T14:27:37.121Z","description":"How to avoid potential infinite loops of while using useEffect.","tags":["react","reacthooks"],"title":"React Hooks[useEffect()] How to avoid infinite loops"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/React-Hooks-avoid-infinite-loops"}}}