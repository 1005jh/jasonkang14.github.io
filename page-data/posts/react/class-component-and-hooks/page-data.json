{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/react/class-component-and-hooks","webpackCompilationHash":"33fdb2fa4cbbe56306be","result":{"data":{"markdownRemark":{"id":"bbc31527-8b3c-5a3a-97bd-d505c680f997","html":"<p>I have already written about how <code class=\"language-text\">componentDidMount</code>, <code class=\"language-text\">componentDidUpdate</code> could be replaced with <code class=\"language-text\">useEffect()</code> in React Hooks in this <a href=\"https://jasonkang14.github.io/posts/React-Hooks-useEffect-update-when-you-want\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">post</a>.</p>\n<p>And instead of declaring <code class=\"language-text\">this.state</code> inside <code class=\"language-text\">constructor()</code>, you can just use <code class=\"language-text\">useState()</code>, which is supposed to be faster as explained in this <a href=\"https://jasonkang14.github.io/posts/react/react-hooks-useState-explained-with-examples\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">link</a>.</p>\n<p>There is another hook called <code class=\"language-text\">useRef</code>, which can be used to ensure that a certain function is called only when the component is called for the first time. <code class=\"language-text\">useRef</code> hook is used to remember/store the initial value.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Profile = () =&gt; {\n    const [name, setName] = useState(&quot;jason&quot;);\n    const isFirstRef = useRef(true);\n    if (isFirstRef.current) {\n        isFirstRef.current = false;\n        callApi();\n    }\n}</code></pre></div>\n<p>In the function above, <code class=\"language-text\">isFirstRef</code> is initially set <code class=\"language-text\">true</code>, which is why the if clause works, and then the function <code class=\"language-text\">callApi()</code> gets called when the Profile component is called for the first time. However, after calling <code class=\"language-text\">callApi()</code>, the value of <code class=\"language-text\">isFirstRef</code> changes to <code class=\"language-text\">false</code>, therefore, the if clause does not work if the component gets called again.</p>\n<p>If you need to use the same logic in different components, you can create a custom hook like below.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// useOnFirstRender.js\nconst useOnFirstRender = (func) =&gt; {\n    const isFirstRef = useRef(true);\n    if (isFirstRef.current) {\n        isFirstRef.current = false;\n        func();\n    }\n}\n\n// Profile.js\n\nimport useOnFirstRender from &#39;path&#39;;\n\nconst Profile = () =&gt; {\n    const [name, setName] = useState(&quot;jason&quot;);\n    useOnFirstRender(callApi);\n}</code></pre></div>\n<p>Changing <code class=\"language-text\">getDerivedStateFromProps</code> is interesting. I posted about <code class=\"language-text\">getDerivedStateFromProps</code> <a href=\"https://jasonkang14.github.io/posts/react/react-life-cycle-get-derived-state-from-props-with-mobx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a>. Instead of comparing a newly received props and a previously stored state as you would do in a class component, you can easily do it using <code class=\"language-text\">useState()</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const SpeedIndicator = ({ speed }) =&gt; {\n    const [isFaster, setIsFaster] = useState(false);\n    const [prevSpeed, setPrevSpeed] = useState(0);\n\n    if (speed !== prevSpeed) {\n        setIsFaster(speed &gt; prevSpeed);\n        setPrevSpeed(speed);\n    }\n}</code></pre></div>\n<p>The values of <code class=\"language-text\">isFaster</code> and <code class=\"language-text\">prevSpeed</code> changes right away as the state changes. Apprently this is slightly less efficient than using 1<code class=\"language-text\">getDerivedStateFromProps</code>, but it shouldn’t be too bad since it happens before forming DOM.</p>\n<p><code class=\"language-text\">useDebounce</code> provides a debounce, which is a higher-order function that returns another function. To be honest, I am not sure why you would use this.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const useDebounce = ({ callback, ms, args }) =&gt; {\n    useEffect(() =&gt; {\n        const id = setTimeout(callback, ms);\n        return () =&gt; clearTimeout(id);\n    }, args)\n}\n\nconst Profile = () =&gt; {\n    let [name, setName] = useState(&quot;&quot;);\n    let [nameTemp, setNameTemp] = useState(&quot;&quot;);\n    useDebounce({\n        callback: () =&gt; setName(nameTemp),\n        ms: 1000,\n        args: [nameTemp],\n    });\n}</code></pre></div>\n<p>It looks like, after a second, the <code class=\"language-text\">useDebounce</code> hook <code class=\"language-text\">setName</code> the <code class=\"language-text\">name</code> state as <code class=\"language-text\">nameTemp</code>. I feel like a custom hook is just creating a separate function that you might use in different components. Personally, I don’t see a point of using a <code class=\"language-text\">hook</code> called <code class=\"language-text\">useDebounce</code> when you can just create a simple function that has <code class=\"language-text\">setTimeout</code>. If I get to think otherwise later on, I will post about it as well.</p>\n<p>According to <code class=\"language-text\">usehooks.com</code>: When used in conjunction with useEffect, as we do in the recipe below, you can easily ensure that expensive operations like API calls are not executed too frequently.</p>\n<p><code class=\"language-text\">useHasMounted</code> seems useless. and it is not found anywhere.</p>","fields":{"slug":"/posts/react/class-component-and-hooks","tagSlugs":["/tag/react/","/tag/reacthooks/","/tag/component/","/tag/useref/","/tag/usedebounce/","/tag/usehasmounted/"]},"frontmatter":{"date":"2019-10-16T23:27:37.121Z","description":"React.js class component and hooks: ","tags":["react","reacthooks","component","useref","usedebounce","usehasmounted"],"title":"React Hooks - Rewriting Class Component Using React Hooks"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/react/class-component-and-hooks"}}}